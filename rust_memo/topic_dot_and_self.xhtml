<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust トピック: self とドット演算子について。</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<div class="title">
			<script>Base.insertTitle();</script>
		</div>
		<p>
<code>self</code> とドット演算子によるメソッドの呼出について。
		</p> <p>
ドット演算子はメソッドの呼出のために <code>self</code> に適合するよう左辺側に様々な型変換を行う。
		</p>
		<aside class="normal moan">
			<p>
より単純な糖衣構文だと思っていると、落とし穴にはまる事がある。
			</p>
		</aside>
		<section>
			<h1>型変換の仕様</h1>
			<p>
ドット演算子の左辺が <code>self</code> の型に適合するまで、以下のルールを再帰的に適用する。
			</p>
			<ol>
				<li>
					<p>
元の型をそのまま試す。
					</p>
				</li> <li>
					<p>
元の型を不変参照した型を試す (autoref)。
					</p>
				</li> <li>
					<p>
元の型を可変参照した型を試す (autoref)。
					</p>
				</li> <li>
					<p>
元の型が Deref を実装するなら、参照を外した型を試す (autoderef)。
					</p>
				</li> <li>
					<p>
元の型が固定長配列なら、その全体のスライス型を試す。
					</p>
				</li>
			</ol>
		</section> <section>
			<h1>筆者の体験談</h1>
			<p>
ここでは筆者がしばらくハテナ？となった事例を紹介する。
			</p>
			<div class="sub">
				<h2 id="disabled_sized"><code>Sized</code> 境界が無効に見える例</h2>
				<p>
以下のコードでは、前述のルールを知らないと <code>Sized</code> 境界が機能していないように見える。つまり、ルールの一つ目だけでは <code>Sized</code> 境界によるコンパイルエラーになるべきで、ルールの二つ目によって初めて正常なコードであると評価できる。
				</p>
				<ol>
					<li>
						<p>
ルールの一つ目を適用。
						</p>
						<ul>
							<li>
								<p>
<code>&amp;str</code> をそのまま使おうとする。
								</p>
							</li> <li>
								<p>
<code>&amp;self</code> つまり <code>&amp;T</code> の実際の型は <code>&amp;str</code> が指定される。
								</p>
							</li> <li>
								<p>
結果、<code>T</code> は <code>str</code> となり、これは <code>Sized</code> でないため失敗する。
								</p>
							</li>
						</ul>
					</li> <li>
						<p>
ルールの二つ目を適用。
						</p>
						<ul>
							<li>
								<p>
<code>&amp;str</code> を参照して <code>&amp;&amp;str</code> とする。
								</p>
							</li> <li>
								<p>
<code>&amp;self</code> つまり <code>&amp;T</code> の実際の型は <code>&amp;&amp;str</code> が指定される。
								</p>
							</li> <li>
								<p>
結果、<code>T</code> は <code>&amp;str</code> となり、これは <code>Sized</code> のため成功する。
								</p>
							</li>
						</ul>
					</li>
				</ol>
<pre><code class="language-rust">
fn main() {
    let str: &amp;str = "abc";

    str.method();
	// これは以下のどれかに書換可能。
    // (&amp;str).method();
    // &lt;&amp;str&gt;::method(&amp;str);
    // SomeTrait::method(&amp;str);
}

trait SomeTrait {
    fn method(&amp;self) {}
}

impl&lt;T: Sized&gt; SomeTrait for T {
    // NOP.
}
</code></pre>
			</div>
		</section>
	</body>
</html>
