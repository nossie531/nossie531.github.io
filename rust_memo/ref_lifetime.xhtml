<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: ライフタイムまわりのエラー</title>
		<link rel="_up" href="index.xhtml"/>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><script>Base.insertTitle();</script></h1>
		</header>
		<p>
参照は存在しているだけで、それと競合する各種の操作をコンパイルエラーにする。そして、参照のライフタイムの期間は、基本的にはその参照の最後の使用まで、用法によってはさらに延長される。ここではその延長されるパターンについて紹介する。
		</p>
		<section>
			<h1>関連エラー</h1>
			<p>
			</p> <p>
以下はよくあるエラー。
			</p>
<pre><samp class="console-rustc">
<mark class="error">error[E0502]</mark>: cannot borrow `data` as mutable because it is also borrowed as immutable
</samp></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0502]</mark>: cannot borrow `data` as immutable because it is also borrowed as mutable
</samp></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0503]</mark>: cannot use `data` because it was mutably borrowed
</samp></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0506]</mark>: cannot assign to `target.something` because it is borrowed
</samp></pre>
		</section> <section>
			<h1>ケーススタディ</h1>
			<section>
				<h1 id="ref_to_ref">参照からの参照</h1>
				<p>
参照を辿って別の参照を取得した場合について。
				</p> <p>
この場合、少なくとも新しい参照が使われなくなるまでは、元の参照も維持され、その制限が残るようになる。 
				</p> <p>
これは、元の参照と新しい参照の参照先が、データ構造における全体と部分、またはその逆のような重複した関係となるため、必須の措置である。つまり、新しい参照から部分側の更新を制限をしても、元の参照とその制限がなければ、全体側からの更新ができてしまう。 
				</p> 
				<aside class="normal">
					<p>
コーディングスタイルの強制。
					</p> <p>
この制限はコーディングスタイルの道しるべにもなる。つまり、部分側の処理を終えてからでないと、全体側からの更新ができないため、処理内容によるコードの分離が促進される。
					</p>
				</aside>
				<div class="sub">
					<h2>コンパイルエラーになる例</h2>
					<p>
以下では、参照 <code>&amp;data</code> から参照 <code>sub_ref</code> を得ている。つまり、<code>sub_ref</code> への最後のアクセスまでは、<code>&amp;data</code> も維持され、それと衝突する操作は行えなくなる。
					</p>
<pre><code class="language-rust">
fn main() {
    let mut data = Data { sub: 0 };
    let sub_ref = ref_to_ref(&amp;data);
	<mark class="error">&amp;mut data</mark>;
    println!("{}", sub_ref);
}

fn ref_to_ref(data: &amp;Data) -&gt; &amp;i32 {
    &amp;data.sub
}

struct Data {
    sub: i32,
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0502]</mark>: cannot borrow `data` as mutable because it is also borrowed as immutable
<mark class="info"> --&gt;</mark> src\main.rs:4:2
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     let sub_ref = ref_to_ref(&amp;data);
<mark class="info">  |</mark>                              <mark class="info">----- immutable borrow occurs here</mark>
<mark class="info">4 |</mark>     &amp;mut data;
<mark class="info">  |</mark>     <mark class="error">^^^^^^^^^ mutable borrow occurs here</mark>
<mark class="info">5 |</mark>     println!("{}", sub_ref);
<mark class="info">  |</mark>                    <mark class="info">------- immutable borrow later used here</mark>
</samp></pre>
				</div>
			</section> <section>
				<h1>可変参照からの参照</h1>
				<p>
可変参照を辿って別の参照を取得した場合について。
				</p> <p> 
まず、基本は『<a href="#ref_to_ref">参照からの参照</a>』の通り。つまり、少なくとも新しい参照が使われなくなるまでは、元の参照も維持され、その制限が残るようになる。
				</p> <p> 
さらに、元の参照からの操作は全て禁止されるようになる。そのため、新しい参照がある間の操作はそこからに一本化される。
				</p>
				<aside class="normal">
					<p>
よくある疑問。
					</p> <p> 
可変参照を辿って不変参照を取得した場合でも、ルールは変わらない。元の参照からの操作は全て禁止される。この場合、参照を辿る処理は可変から不変へのダウングレード処理としても解釈できるため、読取系の操作ならば許しても良いのでは？と思われるかもしれない。そして実際、これは多くの場合はその通りである。
					</p> <p> 
しかし、これは一部のケースで『<a href="#with_interior_mutable_type">内部可変型との関係</a>』のためうまくいかなくなる。そして、データ構造に内部可変型が含まれるかは動的に変わりうるため、静的解析により特例を設けることもできない。そのため、この仕様は全てのケースで一貫して適用される。
				</p> 
				</aside>
				<div class="sub">
					<h2>コンパイルエラーになる例</h2>
					<p>
以下では、参照 <code>&amp;mut data</code> から <code>sub_ref</code> を得ている。そのため、<code>sub_ref</code> への最後のアクセスまでは、<code>&amp;mut data</code> も維持され、それと衝突する操作は行えなくなる。
					</p>
<pre><code class="language-rust">
fn main() {
    let mut data = Data { sub: 0 };
    let sub_ref = mut_to_ref(&amp;mut data);
	<mark class="error">&amp;data</mark>;
    println!("{}", sub_ref);
}

fn mut_to_ref(data: &amp;mut Data) -&gt; &amp;i32 {
    &amp;data.sub
}

struct Data {
    sub: i32,
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0502]</mark>: cannot borrow `data` as immutable because it is also borrowed as mutable
<mark class="info"> --&gt;</mark> src\main.rs:4:2
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     let sub_ref = mut_to_ref(&amp;mut data);
<mark class="info">  |</mark>                              <mark class="info">--------- mutable borrow occurs here</mark>
<mark class="info">4 |</mark>     &amp;data;
<mark class="info">  |</mark>     <mark class="error">^^^^^ immutable borrow occurs here</mark>
<mark class="info">5 |</mark>     println!("{}", sub_ref);
<mark class="info">  |</mark>                    <mark class="info">------- mutable borrow later used here</mark>
</samp></pre>
				</div>
				<div class="sub">
					<h2 id="with_interior_mutable_type">内部可変型との関係</h2>
					<p>
内部可変型への参照には、それが格納する型への参照とで、相互に読替できるものがある。この時、読替先へのアクセスの代わりに、読替元へのアクセスを禁止しなければならない。そうしないと、読替元か読替先のどちらかは内部可変型のため、一方からの読込と他方からの書込がともに許される区間ができてしまう。
					</p> <p>
そこで、可変参照からの参照の制限が役に立つ。
					</p> 
					<p>
以下は <code>std</code> クレートでのそうした関数 (他にもあるかも…)。
					</p>
					<table class="normal" style="width: 0;">
						<tr>
							<td style="padding-right: 2ch; white-space: nowrap; border-right-style: dashed;">
<code style="background: initial;"><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html">Cell</a>&lt;T&gt;</code>
							</td> <td style="padding-right: 2ch; white-space: nowrap; border-left-style: dashed;">
<code style="background: initial;">fn <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.from_mut">from_mut</a>(t: &amp;mut T) -&gt; &amp;Cell&lt;T&gt;</code>
							</td>
						</tr> <tr>
							<td style="padding-right: 2ch; white-space: nowrap; border-right-style: dashed;">
<code style="background: initial;"><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html">Cell</a>&lt;T&gt;</code>
							</td> <td style="padding-right: 2ch; white-space: nowrap; border-left-style: dashed;">
<code style="background: initial;">fn <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get_mut">get_mut</a>(&amp;mut self) -&gt; &amp;mut T</code>
							</td>
						</tr> <tr>
							<td style="padding-right: 2ch; white-space: nowrap; border-right-style: dashed;">
<code style="background: initial;"><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a>&lt;T&gt;</code>
							</td> <td style="padding-right: 2ch; white-space: nowrap; border-left-style: dashed;">
<code style="background: initial;">fn <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.get_mut">get_mut</a>(&amp;mut self) -&gt; &amp;mut T</code>
							</td>
						</tr>
					</table>
					<p>
以下は <code>RefCell</code> による例。不変参照中の値の更新をコンパイルエラーで予防している。
					</p> 
<pre><code class="language-rust">
use std::cell::RefCell;

fn main() {
    let mut target = RefCell::new(0);
    let immutable_ref = get_ref_cell_value(&amp;mut target);

    assert_eq!(*immutable_ref, 0);
    set_ref_cell_value(<mark class="error">&amp;target</mark>, 1);
    assert_eq!(*immutable_ref, 0);
}

fn get_ref_cell_value(mutable_ref: &amp;mut RefCell&lt;i32&gt;) -&gt; &amp;i32 {
    &amp;*mutable_ref.get_mut()
}

fn set_ref_cell_value(immutable_ref: &amp;RefCell&lt;i32&gt;, value: i32) {
    *immutable_ref.borrow_mut() = value;
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0502]</mark>: cannot borrow `target` as immutable because it is also borrowed as mutable
<mark class="info"> --&gt;</mark> src\main.rs:8:24
<mark class="info">  |</mark>
<mark class="info">5 |</mark>     let immutable_ref = get_ref_cell_value(&amp;mut target);
<mark class="info">  |</mark>                                            <mark class="info">----------- mutable borrow occurs here</mark>
<mark class="info">...</mark>
<mark class="info">8 |</mark>     set_ref_cell_value(&amp;target, 1);
<mark class="info">  |</mark>                        <mark class="error">^^^^^^^ immutable borrow occurs here</mark>
<mark class="info">9 |</mark>     assert_eq!(*immutable_ref, 0);
<mark class="info">  |</mark>     <mark class="info">----------------------------- mutable borrow later used here</mark>
</samp></pre>
				</div>
			</section> <section>
				<h1>特殊な入れ子の参照</h1>
				<p>
<code>&amp;'a A&lt;'a&gt;</code> のような指定について。つまり、構造体への参照と構造体からの参照とが、同じライフタイム注釈を持つ場合について。
				</p> <p>
このような借用を行った場合、その借用は、その構造体が破棄されるまで返却されなくなる。なぜなら、[構造体への参照のライフタイム] ⊆ [構造体の存在期間] ⊆ [構造体からの参照のライフタイム] の包含関係において、両サイドが同じになるため、全体での等号が成立する。これにより、参照のライフタイムが構造体の存在期間と一致する事になる。
				</p>
				<aside class="normal">
					<p>
このパターンの代表例。
					</p> <p>
このパターンがよく使われるのはアリーナのようなデータ構造である。アリーナでは、最初に一括で確保された構造体どうしが相互参照する。このような場合、構造体への参照と構造体からの参照とで有効期間が一致するため、このパターンが必要になる。
					</p>
				</aside>
				<aside class="normal">
					<p>
気付きにくい例。
					</p> <p>
<code>self</code> や <code>Self</code> などの型指定により、このパターンになっている事に気付きにくい場合がある。例えば、<code>SomeStruct&lt;'a&gt;</code> のような構造体で <code>&amp;'a self</code> のような引数型のメソッドがあれば、それはこのパターンに該当する。
					</p>
				</aside>
				<div class="sub">
					<h2>コンパイルエラーになる例</h2>
					<p>
以下では、参照 <code>&amp;mut data</code> と構造体の変数 <code>data</code> で問題の処理が発生する。そのため、<code>data</code> がある間は、参照 <code>&amp;mut data</code> も残り、それと衝突する操作は行えなくなる。
					</p>
<pre><code class="language-rust">
fn main() {
    let context = 0;
    let mut data = Data { context: &amp;context };
    use_data_mut(&amp;mut data);
    <mark class="error">&amp;data</mark>;
}

fn use_data_mut&lt;'a&gt;(_data: &amp;'a mut Data&lt;'a&gt;) {
    /* ... */
}

struct Data&lt;'a&gt; {
    context: &amp;'a i32,
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0502]</mark>: cannot borrow `data` as immutable because it is also borrowed as mutable
<mark class="info"> --&gt;</mark> src\main.rs:5:5
<mark class="info">  |</mark>
<mark class="info">4 |</mark>     use_data_mut(&amp;mut data);
<mark class="info">  |</mark>                  <mark class="info">--------- mutable borrow occurs here</mark>
<mark class="info">5 |</mark>     &amp;data;
<mark class="info">  |</mark>     <mark class="error">^^^^^</mark>
<mark class="info">  |</mark>     <mark class="error">|</mark>
<mark class="info">  |</mark>     <mark class="error">immutable borrow occurs here</mark>
<mark class="info">  |</mark>     <mark class="error">mutable borrow later used here</mark>
</samp></pre>
				</div>
			</section> 
		</section>
	</body>
</html>
