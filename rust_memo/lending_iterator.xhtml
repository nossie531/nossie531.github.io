<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: Lending Iterator パターン</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><script>Base.insertTitle();</script></h1>
		</header>
		<p>
Iterator パターンの変種、Lending Iterator パターンについて。
		</p>
		<section>
			<h1><code>Iterator</code> の特徴</h1>
			<p>
標準機能のトレイト <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a> について。
			</p> <p>
アイテムがイテレータとライフタイムを共有しない。
			</p> <p>
つまり、イテレータを破棄してもアイテムの使用を続けられる。 
			</p>
		</section> <section>
			<h1><code>LendingIterator</code> の特徴</h1>
			<p>
標準機能には Lending Iterator のためのトレイトはまだないので自分で定義する。
			</p> <p>
アイテムがイテレータとライフタイムを共有する (アイテム型にライフタイム引数がある)。
			</p> <p>
つまり、イテレータを破棄するとアイテムの使用を続けられなくなる。
			</p>
		</section> <section>
			<h1><code>LendingIterator</code> の実装例</h1>
			<section>
				<h2><code>WindowsMut</code></h2>
				<p>
このイテレータのアイテムは配列への可変スライスで、スライスの開始位置はアイテムの取得ごとに一歩ずつ前進し、スライスの長さは初期化時に指定された固定長になる。
				</p> <p>
なお、このイテレータは通常のイテレータと異なり、同じイテレータ由来の複数のアイテムが同時に存在できない。なぜなら、各アイテムは同じイテレータを可変参照しているため、借用チェッカーによる排他制御下にある。これにより、複数の可変スライスの範囲が重複して編集が競合するような事態を予防できる。
				</p>
			</section>
		</section> <section>
			<h1>サンプル</h1>
			<p>
以下では、トレイト <code>LendingIterator</code> を型 <code>WindowsMut</code> に実装している。
			</p>
<pre><code class="language-rust">
fn main() {
    let mut arr = [1, 2, 3];
    let mut iter = WindowsMut::new(&amp;mut arr, 2);
    assert_eq!(iter.next(), Some([1, 2].as_mut_slice()));
    assert_eq!(iter.next(), Some([2, 3].as_mut_slice()));
    assert_eq!(iter.next(), None);
}

trait LendingIterator {
    type Item&lt;'a&gt; where Self: 'a;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&lt;'_&gt;&gt;;
}

struct WindowsMut&lt;'arr, T&gt; {
    slice: &amp;'arr mut [T],
    size: usize,
    pos: usize,
}

impl&lt;'arr, T&gt; WindowsMut&lt;'arr, T&gt; {
    fn new(slice: &amp;'arr mut [T], size: usize) -&gt; Self {
        assert_ne!(size, 0);
        Self { slice, size, pos: 0 }
    }
}

impl&lt;'arr, T&gt; LendingIterator for WindowsMut&lt;'arr, T&gt; {
    type Item&lt;'a&gt; = &amp;'a mut [T] where Self: 'a;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&lt;'_&gt;&gt; {
        let result = self.slice[self.pos..].get_mut(..self.size)?;
        self.pos += 1;
        Some(result)
    }
}
</code></pre>
		</section> <section>
			<h1>問題点</h1>
			<p>
上記のサンプルでは実装に <a href="associated_type.xhtml#gat">GAT</a> を利用している。
			</p> <p>
しかし、<time>2024 年現在</time>、GAT にはまだ<a href="associated_type.xhtml#gat_problem">問題点</a>が多い。
			</p> <p>
GAT のポリフィルではこうした問題点がないため、それを利用した <a href="https://crates.io/crates/lending-iterator"><code>lending-iterator</code></a> のようなクレートも存在するが、それらでは API がかなり複雑になっている。
			</p>
		</section>
	</body>
</html>
