<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: E0599 - 無効なメソッドの呼出</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method` found for struct `MyType` in the current scope</mark>
</samp></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: the method `method` exists for struct `MyType&lt;Xxx&gt;`, but its trait bounds were not satisfied</mark>
</samp></pre>
		<p>
無効なメソッドの呼出を行った。
		</p>
		<section>
			<h1>パターン</h1>
			<doc-nav-sub/>
			<section>
				<hgroup>
					<h1>パターン A</h1>
					<div class="subTitle">基本形</div>
				</hgroup>
				<p>
呼び出そうとしたメソッドが型にそもそもないパターン。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、型 <code>MyValue</code> にメソッド <code>method</code> が存在しない。
					</p>
<pre><code class="language-rust">
fn main() {
    let value = MyValue();
    value.<mark class="error">method</mark>();
}

struct MyValue();
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method` found for struct `MyValue` in the current scope</mark>
<mark class="info"> --&gt;</mark> src\main.rs:3:11
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     value.method();
<mark class="info">  |</mark>           <mark class="error">^^^^^^ method not found in `MyValue`</mark>
<mark class="info">...</mark>
<mark class="info">6 |</mark> struct MyValue();
<mark class="info">  |</mark> <mark class="info">-------------- method `method` not found for this struct</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1>パターン B</h1>
					<div class="subTitle">境界への不適合</div>
				</hgroup>
				<p>
呼び出そうとしたメソッドは型にあるが、境界に適合しないパターン。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、型 <code>MyValue&lt;T&gt;</code> にメソッド <code>print_binary</code> があるが、境界に適合せず呼べない。なぜなら、型パラメタ <code>T</code> に割り当てられた型は <code>bool</code> であり、これは <code>T</code> が <code>UpperHex</code> を実装すべきとした実装時の境界に違反する。
					</p>
<pre><code class="language-rust">
use std::fmt::UpperHex;

fn main() {
    let value = MyValue(true);
    value.<mark class="error">print_binary</mark>();
}

struct MyValue&lt;T&gt;(T);
impl&lt;T: UpperHex&gt; MyValue&lt;T&gt; {
    fn print_binary(&amp;self) {
        println!("{:X}", self.0)
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: the method `print_binary` exists for struct `MyValue&lt;bool&gt;`, but its trait bounds were not satisfied</mark>
<mark class="info"> --&gt;</mark> src\main.rs:5:11
<mark class="info">  |</mark>
<mark class="info">5 |</mark>     value.print_binary();
<mark class="info">  |</mark>           <mark class="error">^^^^^^^^^^^^ method cannot be called on `MyValue&lt;bool&gt;` due to unsatisfied trait bounds</mark>
<mark class="info">...</mark>
<mark class="info">8 |</mark> struct MyValue&lt;T&gt;(T);
<mark class="info">  |</mark> <mark class="info">----------------- method `print_binary` not found for this struct</mark>
<mark class="info">  |</mark>
<mark class="edit">note</mark>: trait bound `bool: UpperHex` was not satisfied
<mark class="info"> --&gt;</mark> src\main.rs:9:9
<mark class="info">  |</mark>
<mark class="info">9 |</mark> impl&lt;T: UpperHex&gt; MyValue&lt;T&gt; {
<mark class="info">  |</mark>         <mark class="edit">^^^^^^^^</mark>  <mark class="info">----------</mark>
<mark class="info">  |</mark>         <mark class="edit">|</mark>
<mark class="info">  |</mark>         <mark class="edit">unsatisfied trait bound introduced here</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1 id="hrtbTypeInference">パターン C</h1>
					<div class="subTitle">HRTB を期待する型推論</div>
				</hgroup>
				<p>
『<a href="hrtb.xhtml">HRTB</a> - <a href="typeInference">型推論</a>』で紹介する通り、HRTB を含んだ型は型推論できない。
				</p> <p>
そのため、型推論により型が決定された変数は、HRTB を境界とする実装に適合しない。
				</p>
				<aside class="normal moan">
					<p id="next-solver">エラーの内容について。</p>
					<p>
よく見るとエラーメッセージの内容が不自然である。なお、<time>2025 年現在</time>、開発中のトレイトソルバーである <a href="nightly_unstable.xhtml#next-solver">next-solver</a> を試用した場合、妥当なメッセージが出力されていた。
					</p>
				</aside>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、<code>MyType&lt;T&gt;::method</code> を呼ぶには、型パラメタ <code>T</code> が HRTB を含んだ境界を満たす必要がある。しかし、<code>_</code> による型推論は、通常のライフタイム注釈しか推論できない。
					</p>
<pre><code class="language-rust">
fn main() {
    let var = MyType(|_| {});
	var.<mark class="error">method</mark>();
}

struct MyType&lt;T&gt;(T);
impl&lt;T&gt; MyType&lt;T&gt; where T: Fn(&amp;i32) {
    fn method(&amp;self) {}
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method` found for struct `MyType&lt;{closure@src\main.rs:2:22: 2:25}&gt;` in the current scope</mark>
<mark class="info"> --&gt;</mark> src\main.rs:3:9
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     var.method();
<mark class="info">  |</mark>         <mark class="error">^^^^^^ method not found in `MyType&lt;{closure@main.rs:2:22}&gt;`</mark>
<mark class="info">...</mark>
<mark class="info">6 |</mark> struct MyType&lt;T&gt;(T);
<mark class="info">  |</mark> <mark class="info">---------------- method `method` not found for this struct</mark>
<mark class="info">  |</mark>
<mark class="info">  =</mark> <mark class="title">note</mark>: the method was found for
<mark class="info">   </mark>       - `MyType&lt;T&gt;`
</samp></pre>
				</section> <section>
					<h2>解決策</h2>
					<p>
HRTB を期待する箇所の参照を推論せずに明示するとよい。
					</p>
<pre><code class="language-rust">
fn main() {
    let var = MyType(|_arg: &amp;_| {});
    var.method();
}

struct MyType&lt;T&gt;(T);
impl&lt;T&gt; MyType&lt;T&gt; where T: Fn(&amp;i32) {
    fn method(&amp;self) {}
}
</code></pre>
				</section>
			</section>
		</section>
	</body>
</html>
