<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: E0599 - 無効なメソッドの呼出</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method` found for struct `MyType` in the current scope</mark>
</samp></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: the method `method` exists for struct `MyType&lt;Xxx&gt;`, but its trait bounds were not satisfied</mark>
</samp></pre>
		<p>
無効なメソッドの呼出を行った。
		</p>
		<section>
			<h1>パターン</h1>
			<doc-nav-sub/>
			<section>
				<hgroup>
					<h1>パターン A</h1>
					<div class="subTitle">基本形</div>
				</hgroup>
				<p>
対象のメソッドが型にそもそもないパターン。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、型 <code>MyValue</code> にメソッド <code>method</code> が存在しない。
					</p>
<pre><code class="language-rust">
fn main() {
    let value = MyValue();
    value.<mark class="error">method</mark>();
}

struct MyValue();
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method` found for struct `MyValue` in the current scope</mark>
<mark class="info"> --&gt;</mark> src\main.rs:3:11
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     value.method();
<mark class="info">  |</mark>           <mark class="error">^^^^^^ method not found in `MyValue`</mark>
<mark class="info">...</mark>
<mark class="info">6 |</mark> struct MyValue();
<mark class="info">  |</mark> <mark class="info">-------------- method `method` not found for this struct</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1>パターン B</h1>
					<div class="subTitle">変数の隠蔽</div>
				</hgroup>
				<p>
対象のメソッドを持つ変数が同名の変数で隠蔽されているパターン。
				</p>
				<section>
					<h2>サンプル</h2>
<pre><code class="language-rust">
fn main() {
    let x = MyTypeX();
    let x = x.conv();
    x.method_of_x();
}

struct MyTypeX();
struct MyTypeY();

impl MyTypeX {
    pub fn conv(self) -&gt; MyTypeY {
        MyTypeY()
    }

    pub fn method_of_x(&amp;self) {
        // nop.
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method_of_x` found for struct `MyTypeY` in the current scope</mark>
<mark class="info"> --&gt;</mark> src\main.rs:4:7
<mark class="info">  |</mark>
<mark class="info">4 |</mark>     x.method_of_x();
<mark class="info">  |</mark>       <mark class="error">^^^^^^^^^^^ method not found in `MyTypeY`</mark>
<mark class="info">...</mark>
<mark class="info">8 |</mark> struct MyTypeY();
<mark class="info">  |</mark> <mark class="info">-------------- method `method_of_x` not found for this struct</mark>
<mark class="info">  |</mark>
<mark class="edit">note</mark>: there's an earlier shadowed binding `x` of type `MyTypeX` that has method `method_of_x` available
<mark class="info"> --&gt;</mark> src\main.rs:2:9
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let x = MyTypeX();
<mark class="info">  |</mark>         <mark class="edit">^ `x` of type `MyTypeX` that has method `method_of_x` defined earlier here</mark>
<mark class="info">3 |</mark>     let x = x.conv();
<mark class="info">  |</mark>         <mark class="info">- earlier `x` shadowed here with type `MyTypeY`</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1>パターン C</h1>
					<div class="subTitle">関連関数との取り違え</div>
				</hgroup>
				<p>
対象のメソッドが型になく、代わりに同名の関連関数があるパターン。
				</p>
				<section>
					<h2>サンプル</h2>
<pre><code class="language-rust">
fn main() {
    let ret = MyType(42).<mark class="error">add</mark>(1);
    assert_eq!(ret, MyType(43))
}

#[derive(PartialEq)]
struct MyType(i32);

impl MyType {
    pub fn add(x: Self, value: i32) -&gt; Self {
        Self(x.0 + value)
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `add` found for struct `MyType` in the current scope</mark>
<mark class="info">  --&gt;</mark> src\main.rs:2:26
<mark class="info">   |</mark>
<mark class="info"> 2 |</mark>     let ret = MyType(42).add(1);
<mark class="info">   |</mark>               <mark class="info">-----------</mark><mark class="error">^^^</mark><mark class="info">---</mark>
<mark class="info">   |</mark>               <mark class="info">|          </mark><mark class="error">|</mark>
<mark class="info">   |</mark>               <mark class="info">|          </mark><mark class="error">this is an associated function, not a method</mark>
<mark class="info">   |</mark>               <mark class="info">help: use associated function syntax instead: `MyType::add(MyType(42), 1)`</mark>
<mark class="info">...</mark>
<mark class="info"> 7 |</mark> struct MyType(i32);
<mark class="info">   |</mark> <mark class="info">------------- method `add` not found for this struct</mark>
<mark class="info">   |</mark>
<mark class="info">   =</mark> <mark class="title">note</mark>: found the following associated functions; to be used as methods, functions must have a `self` parameter
<mark class="edit">note</mark>: the candidate is defined in an impl for the type `MyType`
<mark class="info">  --&gt;</mark> src\main.rs:10:5
<mark class="info">   |</mark>
<mark class="info">10 |</mark>     pub fn add(x: Self, value: i32) -&gt; Self {
<mark class="info">   |</mark>     <mark class="edit">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</mark>
<mark class="info">   =</mark> <mark class="title">help</mark>: items from traits can only be used if the trait is implemented and in scope
<mark class="info">   =</mark> <mark class="title">note</mark>: the following trait defines an item `add`, perhaps you need to implement it:
<mark class="info">    </mark>       candidate #1: `Add`
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1>パターン D1</h1>
					<div class="subTitle">境界への不適合 (通常版)</div>
				</hgroup>
				<p>
対象のメソッドは型にあるが、境界に適合しないパターン。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、型 <code>MyValue&lt;T&gt;</code> にメソッド <code>print_binary</code> があるが、境界に適合せず呼べない。なぜなら、型パラメタ <code>T</code> に割り当てられた型は <code>bool</code> であり、これは <code>T</code> が <code>UpperHex</code> を実装すべきとした実装時の境界に違反する。
					</p>
<pre><code class="language-rust">
use std::fmt::UpperHex;

fn main() {
    let value = MyValue(true);
    value.<mark class="error">print_binary</mark>();
}

struct MyValue&lt;T&gt;(T);
impl&lt;T: UpperHex&gt; MyValue&lt;T&gt; {
    fn print_binary(&amp;self) {
        println!("{:X}", self.0)
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: the method `print_binary` exists for struct `MyValue&lt;bool&gt;`, but its trait bounds were not satisfied</mark>
<mark class="info"> --&gt;</mark> src\main.rs:5:11
<mark class="info">  |</mark>
<mark class="info">5 |</mark>     value.print_binary();
<mark class="info">  |</mark>           <mark class="error">^^^^^^^^^^^^ method cannot be called on `MyValue&lt;bool&gt;` due to unsatisfied trait bounds</mark>
<mark class="info">...</mark>
<mark class="info">8 |</mark> struct MyValue&lt;T&gt;(T);
<mark class="info">  |</mark> <mark class="info">----------------- method `print_binary` not found for this struct</mark>
<mark class="info">  |</mark>
<mark class="edit">note</mark>: trait bound `bool: UpperHex` was not satisfied
<mark class="info"> --&gt;</mark> src\main.rs:9:9
<mark class="info">  |</mark>
<mark class="info">9 |</mark> impl&lt;T: UpperHex&gt; MyValue&lt;T&gt; {
<mark class="info">  |</mark>         <mark class="edit">^^^^^^^^</mark>  <mark class="info">----------</mark>
<mark class="info">  |</mark>         <mark class="edit">|</mark>
<mark class="info">  |</mark>         <mark class="edit">unsatisfied trait bound introduced here</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup id="deriveAttribute">
					<h1>パターン D2</h1>
					<div class="subTitle">境界への不適合 (<code>derive</code> 属性版)</div>
				</hgroup>
				<p>
対象のメソッドは型にあるが、そのメソッドが <code>derive</code> 属性で実装されたトレイトのメソッドであり、その境界に適合しないパターン。
				</p> <p>
『<a href="derive_attribute.xhtml">derive 属性</a> - <a href="derive_attribute.xhtml#typeParam">型パラメタの影響</a>』で紹介する通り、<code>derive</code> 属性は型パラメタについての境界を導入する場合が多い。この境界に違反するとエラーになる。なお、下記のサンプルではエラーメッセージがその境界 <code>T: Default</code> について指摘しているが、ソース中に該当箇所が存在しない。そのため、混乱しやすい。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、<code>MyVec&lt;T&gt;</code> の <code>Deault</code> の実装は <code>derive</code> 属性に由来するため、<code>T: Default</code> の境界を持つ。しかし、<code>MyVec::&lt;T&gt;::default()</code> における <code>T</code> は <code>Clone</code> しか実装していない。
					</p>
<pre><code class="language-rust">
fn main() {
    let values = values(1, 3);
    assert_eq!(values.0, vec![1, 1, 1]);
}

fn values&lt;T: Clone&gt;(value: T, len: usize) -&gt; MyVec&lt;T&gt; {
    let mut ret = MyVec::&lt;T&gt;::<mark class="error">default</mark>();
    for _ in 0..len {
        ret.0.push(value.clone());
    }

    ret
}

#[derive(Default, Clone, PartialEq)]
struct MyVec&lt;T&gt;(Vec&lt;T&gt;);
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: the function or associated item `default` exists for struct `MyVec&lt;T&gt;`, but its trait bounds were not satisfied</mark>
<mark class="info">  --&gt;</mark> src\main.rs:7:31
<mark class="info">   |</mark>
<mark class="info"> 7 |</mark>     let mut ret = MyVec::&lt;T&gt;::default();
<mark class="info">   |</mark>                               <mark class="error">^^^^^^^ function or associated item cannot be called on `MyVec&lt;T&gt;` due to unsatisfied trait bounds</mark>
<mark class="info">...</mark>
<mark class="info">16 |</mark> struct MyVec&lt;T&gt;(Vec&lt;T&gt;);
<mark class="info">   |</mark> <mark class="info">--------------- function or associated item `default` not found for this struct because it doesn't satisfy `MyVec&lt;T&gt;: Default`</mark>
<mark class="info">   |</mark>
<mark class="edit">note</mark>: trait bound `T: Default` was not satisfied
<mark class="info">  --&gt;</mark> src\main.rs:15:10
<mark class="info">   |</mark> 
<mark class="info">15 |</mark> #[derive(Default, Clone, PartialEq)]
<mark class="info">   |</mark>          <mark class="edit">^^^^^^^ unsatisfied trait bound introduced in this `derive` macro</mark>
<mark class="info">help</mark>: consider restricting the type parameter to satisfy the trait bound
<mark class="info">   |</mark>
<mark class="info"> 6 |</mark> fn values&lt;T: Clone&gt;(value: T, len: usize) -&gt; MyVec&lt;T&gt; <mark class="edit">where T: Default</mark> {
<mark class="info">   |</mark>                                                       <mark class="edit">++++++++++++++++</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1 id="hrtbTypeInference">パターン E</h1>
					<div class="subTitle">HRTB を期待する型推論</div>
				</hgroup>
				<p>
『<a href="hrtb.xhtml">HRTB</a> - <a href="hrtb.xhtml#typeInference">型推論</a>』で紹介する通り、HRTB を含んだ型は型推論できない。
				</p> <p>
そのため、型推論により型が決定された変数は、HRTB を境界とする実装に適合しない。
				</p>
				<aside class="normal moan">
					<p id="next-solver">エラーの内容について。</p>
					<p>
よく見るとエラーメッセージの内容が不自然である。なお、<time>2025 年現在</time>、開発中のトレイトソルバーである <a href="nightly_unstable.xhtml#next-solver">next-solver</a> を試用した場合、妥当なメッセージが出力されていた。
					</p>
				</aside>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、<code>MyType&lt;T&gt;::method</code> を呼ぶには、型パラメタ <code>T</code> が HRTB を含んだ境界を満たす必要がある。しかし、<code>_</code> による型推論は、通常のライフタイム注釈しか推論できない。
					</p>
<pre><code class="language-rust">
fn main() {
    let var = MyType(|_| {});
	var.<mark class="error">method</mark>();
}

struct MyType&lt;T&gt;(T);
impl&lt;T&gt; MyType&lt;T&gt; where T: Fn(&amp;i32) {
    fn method(&amp;self) {}
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0599]</mark><mark class="title">: no method named `method` found for struct `MyType&lt;{closure@src\main.rs:2:22: 2:25}&gt;` in the current scope</mark>
<mark class="info"> --&gt;</mark> src\main.rs:3:9
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     var.method();
<mark class="info">  |</mark>         <mark class="error">^^^^^^ method not found in `MyType&lt;{closure@main.rs:2:22}&gt;`</mark>
<mark class="info">...</mark>
<mark class="info">6 |</mark> struct MyType&lt;T&gt;(T);
<mark class="info">  |</mark> <mark class="info">---------------- method `method` not found for this struct</mark>
<mark class="info">  |</mark>
<mark class="info">  =</mark> <mark class="title">note</mark>: the method was found for
<mark class="info">   </mark>       - `MyType&lt;T&gt;`
</samp></pre>
				</section> <section>
					<h2>解決策</h2>
					<p>
HRTB を期待する箇所の参照を推論せずに明示するとよい。
					</p>
<pre><code class="language-rust">
fn main() {
    let var = MyType(|_arg: &amp;_| {});
    var.method();
}

struct MyType&lt;T&gt;(T);
impl&lt;T&gt; MyType&lt;T&gt; where T: Fn(&amp;i32) {
    fn method(&amp;self) {}
}
</code></pre>
				</section>
			</section>
		</section>
	</body>
</html>
