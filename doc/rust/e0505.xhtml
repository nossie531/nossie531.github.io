<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: E0505 - 参照中の変数の移動</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
<pre><samp class="console-rustc">
<mark class="error">error[E0505]</mark><mark class="title">: cannot move out of `var` because it is borrowed</mark>
</samp></pre>
		<p>
参照中の変数を移動しようとした。
		</p>
		<section>
			<h1>注意点</h1>
			<p>
このエラー自体のルールは単純である。
			</p> <p>
しかし、エラーを読み解くには、参照まわりのその他の知識も必要になる事がある。
			</p> <p>
例えば､『<a href="e_ref_lifetime.xhtml">ライフタイムの延長</a>』の影響があると、初見では納得しにくいエラーになる。 
			</p>
		</section> <section>
			<h1>メッセージ</h1>
			<p>
メッセージの構成はだいたい以下のようになる。
			</p>
			<dl class="normal">
				<dt>要約部</dt>
				<dd>
					<ul>
						<li>
参照中の移動が検出された変数名
						</li>
					</ul>
				</dd>
				<dt>詳細部</dt>
				<dd>
					<ul>
						<li>
変数の束縛箇所 ← 問題の変数の導入部
						</li> <li>
参照の発生個所 ← エラー個所より前方
						</li> <li>
書込の発生個所 ← エラー個所
						</li> <li>
参照の使用箇所 ← エラー個所より後方 
						</li> <li>
<code>clone</code> の提案
						</li>
					</ul>
				</dd>
			</dl>
		</section> <section>
			<h1>パターン</h1>
			<doc-nav-sub/>
			<section>
				<hgroup>
					<h1>パターン A1</h1>
					<div class="subTitle">基本形 (<code>Clone</code> 実装なし)</div>
				</hgroup>
				<p>
単純に条件を満たした場合について。
				</p>
				<section>
					<h2>サンプル</h2>
<pre><code class="language-rust">
fn main() {
    let var = MyType();
    let var_ref = &amp;var;
    <mark class="error">var</mark>.consume();
    var_ref.use_ref();
}

struct MyType();

impl MyType {
    pub fn consume(self) {}
    pub fn use_ref(&amp;self) {}
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0505]</mark><mark class="title">: cannot move out of `var` because it is borrowed</mark>
<mark class="info"> --&gt;</mark> src\main.rs:4:5
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let var = MyType();
<mark class="info">  |</mark>         <mark class="info">--- binding `var` declared here</mark>
<mark class="info">3 |</mark>     let var_ref = &amp;var;
<mark class="info">  |</mark>                   <mark class="info">---- borrow of `var` occurs here</mark>
<mark class="info">4 |</mark>     var.consume();
<mark class="info">  |</mark>     <mark class="error">^^^ move out of `var` occurs here</mark>
<mark class="info">5 |</mark>     var_ref.use_ref();
<mark class="info">  |</mark>     <mark class="info">------- borrow later used here</mark>
<mark class="info">  |</mark>
<mark class="edit">note</mark>: if `MyType` implemented `Clone`, you could clone the value
<mark class="info"> --&gt;</mark> src\main.rs:8:1
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     let var_ref = &amp;var;
<mark class="info">  |</mark>                    <mark class="info">--- you could clone this value</mark>
<mark class="info">...</mark>
<mark class="info">8 |</mark> struct MyType();
<mark class="info">  |</mark> <mark class="edit">^^^^^^^^^^^^^ consider implementing `Clone` for this type</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1>パターン A2</h1>
					<div class="subTitle">基本形 (<code>Clone</code> 実装あり)</div>
				</hgroup>
				<p>
前のパターンとほぼ同じだが、<code>Clone</code> を実装済の場合、微妙にメッセージが変わる。
				</p>
				<section>
					<h2>サンプル</h2>
<pre><code class="language-rust">
fn main() {
    let var = MyType();
    let var_ref = &amp;var;
    <mark class="error">var</mark>.consume();
    var_ref.use_ref();
}

#[derive(Clone)]
struct MyType();

impl MyType {
    pub fn consume(self) {}
    pub fn use_ref(&amp;self) {}
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0505]</mark><mark class="title">: cannot move out of `var` because it is borrowed</mark>
<mark class="info"> --&gt;</mark> src\main.rs:4:5
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let var = MyType();
<mark class="info">  |</mark>         <mark class="info">--- binding `var` declared here</mark>
<mark class="info">3 |</mark>     let var_ref = &amp;var;
<mark class="info">  |</mark>                   <mark class="info">---- borrow of `var` occurs here</mark>
<mark class="info">4 |</mark>     var.consume();
<mark class="info">  |</mark>     <mark class="error">^^^ move out of `var` occurs here</mark>
<mark class="info">5 |</mark>     var_ref.use_ref();
<mark class="info">  |</mark>     <mark class="info">------- borrow later used here</mark>
<mark class="info">  |</mark>
<mark class="info">help</mark>: consider cloning the value if the performance cost is acceptable
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     let var_ref = &amp;var<mark class="edit">.clone()</mark>;
<mark class="info">  |</mark>                       <mark class="edit">++++++++</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1 id="withDrop">パターン B</h1>
					<div class="subTitle"><code>Drop</code> トレイトの影響</div>
				</hgroup>
				<p>
詳しくは『<a href="e_drop_lifetime.xhtml">Drop トレイトのライフタイムへの影響</a> - <a href="e_drop_lifetime.xhtml#exLifetime">ライフタイムの延長</a>』を参照。
<br/> (注: <code>Drop</code> トレイトを直接的に扱っていなくても考慮が必要。)
				</p>
				<section>
					<h2>サンプル</h2>
<pre><code class="language-rust">
fn main() {
    let var = MyValue(1);
    let _var_ref = var.new_ref();
    <mark class="error">var</mark>.consume();
}

#[derive(Clone)]
struct MyValue(i32);

impl MyValue {
    fn consume(self) {}

    fn new_ref(&amp;self) -&gt; MyRef&lt;'_&gt; {
        MyRef(&amp;self.0)
    }
}

struct MyRef&lt;'a&gt;(&amp;'a i32);
impl Drop for MyRef&lt;'_&gt; {
    fn drop(&amp;mut self) {
        println!("ID [{}] is drpoped.", self.0)
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0505]</mark><mark class="title">: cannot move out of `var` because it is borrowed</mark>
<mark class="info"> --&gt;</mark> src\main.rs:4:5
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let var = MyValue(1);
<mark class="info">  |</mark>         <mark class="info">--- binding `var` declared here</mark>
<mark class="info">3 |</mark>     let _var_ref = var.new_ref();
<mark class="info">  |</mark>                    <mark class="info">--- borrow of `var` occurs here</mark>
<mark class="info">4 |</mark>     var.consume();
<mark class="info">  |</mark>     <mark class="error">^^^ move out of `var` occurs here</mark>
<mark class="info">5 |</mark> }
<mark class="info">  |</mark> <mark class="info">- borrow might be used here, when `_var_ref` is dropped and runs the `Drop` code for type `MyRef`</mark>
<mark class="info">  |</mark>
<mark class="info">help</mark>: consider cloning the value if the performance cost is acceptable
<mark class="info">  |</mark>
<mark class="info">3 |</mark>     let _var_ref = var<mark class="edit">.clone()</mark>.new_ref();
<mark class="info">  |</mark>                       <mark class="edit">++++++++</mark>
</samp></pre>
				</section>
			</section>
		</section>
	</body>
</html>
