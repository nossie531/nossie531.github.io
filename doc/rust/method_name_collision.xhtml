<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: メソッド名の衝突と破壊的変更</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
		<p>
トレイトどうし又はトレイトと型に同名のメソッドがあると、それらの衝突がありうる。
		</p> <p>
ここでは衝突時におこる問題とその対処法について解説している。
		</p>
		<aside class="normal moan">
			<p>下流クレートの破壊問題</p>
			<p>
上流クレート側にメソッドを追加すると、下流クレート側のメソッド呼出箇所で衝突がおきるようになり、下流クレートが破壊される可能性がある。この問題は後述の『<a href="#caveat1">型 vs トレイト / 注意点</a>』と『<a href="#caveat2">トレイト vs トレイト / 注意点</a>』で触れているが、危険かつ対策が地味に面倒なため厄介である。
			</p>
		</aside>
		<section>
			<h1>基礎知識</h1>
			<p>
メソッドの呼出記法には二通りある。
			</p>
			<dl class="normal">
				<dt>通常記法</dt>
				<dd>
					<p>
例: <code>target.method(arg1, arg2, ...)</code>
					</p> <p>
短く手軽だが、どのトレイトのメソッドか曖昧になりうる記法。
					</p>
				</dd>
				<dt id="FullyQualifiedSyntax">完全修飾記法</dt>
				<dd>
					<p>
例: <code>SomeTrait::method(&amp;target, arg1, arg2, ...)</code>
					</p> <p>
長く煩雑だが、どのトレイトのメソッドか明確になる記法。
					</p>
				</dd>
			</dl>
		</section> <section>
			<h1>型 vs トレイト</h1>
			<p>
同名のメソッドに型由来のものがあれば、通常記法ではそれが優先される。
			</p>
			<section>
				<h1>サンプル</h1>
				<p>
以下では、型 <code>MyType</code> がトレイト <code>MyTrait</code> を実装しており、そのどちらもがメソッド <code>method</code> を持つ。この場合、通常記法による呼出では前者のメソッドが優先される。
				</p>
<pre><code class="language-rust">
fn main() {
    let target = MyType();
    assert_eq!(target.method(), "MyType");
    assert_eq!(MyType::method(&amp;target), "MyType");
    assert_eq!(MyTrait::method(&amp;target), "MyTrait");
}

trait MyTrait {
    fn method(&amp;self) -&gt; &amp;str;
}

struct MyType();

impl MyTrait for MyType {
    fn method(&amp;self) -&gt; &amp;str {
        "MyTrait"
    }
}

impl MyType {
    pub fn method(&amp;self) -&gt; &amp;str {
        "MyType"
    }
}
</code></pre>
			</section> <section>
				<h1 id="caveat1">注意点</h1>
				<p>
上流クレートで追加したメソッドが下流クレートの呼出箇所で衝突する危険性について。
				</p> <p>
引数型などが一致しない場合、コンパイルエラーになる！
				</p> <p>
引数型などが一致した場合、静かに呼出先が変更される！！
				</p>
			</section> <section>
				<h1>対策</h1>
				<p>
残念ながらあまり強力な方法はない…。
				</p> <p>
上流側: 困難 (強いて言うなら下流側の努力を祈るくらい…)
				</p> <p>
下流側: 完全修飾構文の使用 (地味にコードが長く読みにくくなる…)
				</p>
			</section>
		</section> <section>
			<h1>トレイト vs トレイト</h1>
			<p>
同名のメソッドがどちらもトレイト由来の場合、通常記法ではエラーになる。
			</p>
			<section>
				<h1>サンプル</h1>
				<p>
以下では、型 <code>MyType</code> は二つのトレイト <code>TraitX</code> と <code>TraitY</code> を実装しており、そのどちらもがメソッド <code>method</code> を持つ。この場合、通常記法による呼出ではエラーになる。
				</p>
<pre><code class="language-rust">
fn main() {
    let target = MyType();
    assert_eq!(target.<mark class="error">method</mark>(), "XXX");
    assert_eq!(TraitX::method(&amp;target), "TraitX");
    assert_eq!(TraitY::method(&amp;target), "TraitY");
}

struct MyType();
impl TraitX for MyType {}
impl TraitY for MyType {}

trait TraitX {
    fn method(&amp;self) -&gt; &amp;str {
        "TraitX"
    }
}

trait TraitY {
    fn method(&amp;self) -&gt; &amp;str {
        "TraitY"
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0034]</mark><mark class="title">: multiple applicable items in scope</mark>
<mark class="info">  --&gt;</mark> src/main.rs:3:20
<mark class="info">   |</mark>
<mark class="info">3  |</mark>     assert_eq!(target.method(), "XXX");
<mark class="info">   |</mark>                       <mark class="error">^^^^^^ multiple `method` found</mark>
<mark class="info">   |</mark>
<mark class="edit">note</mark>: candidate #1 is defined in an impl of the trait `TraitX` for the type `MyType`
<mark class="info">  --&gt;</mark> src/main.rs:13:5
<mark class="info">   |</mark>
<mark class="info">13 |</mark>     fn method(&amp;self) -&gt; &amp;str {
<mark class="info">   |</mark>     <mark class="edit">^^^^^^^^^^^^^^^^^^^^^^^^</mark>
<mark class="info">note</mark>: candidate #2 is defined in an impl of the trait `TraitY` for the type `MyType`
<mark class="info">  --&gt;</mark> src/main.rs:19:5
<mark class="info">   |</mark>
<mark class="info">19 |</mark>     fn method(&amp;self) -&gt; &amp;str {
<mark class="info">   |</mark>     <mark class="edit">^^^^^^^^^^^^^^^^^^^^^^^^</mark>
<mark class="info">help</mark>: disambiguate the method for candidate #1
<mark class="info">   |</mark>
<mark class="info">3  |</mark>     assert_eq!(TraitX::method(&amp;target), "XXX");
<mark class="info">   |</mark>                <mark class="edit">~~~~~~~~~~~~~~~~~~~~~~~</mark>
<mark class="info">help</mark>: disambiguate the method for candidate #2
<mark class="info">   |</mark>
<mark class="info">3  |</mark>     assert_eq!(TraitY::method(&amp;target), "XXX");
<mark class="info">   |</mark>                <mark class="edit">~~~~~~~~~~~~~~~~~~~~~~~</mark>
</samp></pre>
			</section> <section>
				<h1 id="caveat2">注意点</h1>
				<p>
上流クレートで追加したメソッドが下流クレートの呼出箇所で衝突する危険性について。
				</p> <p>
型がまざる場合とは異なり、トレイトどうしの場合は一律でコンパイルエラーになる。
				</p>
			</section> <section>
				<h1>対策</h1>
				<p>
型がまざる場合よりやや状況はよい。
				</p> <p>
上流側: 型にトレイトのメソッドをコピー (よく使う型ではかなり有効)
				</p> <p>
下流側: 完全修飾構文の使用 (こちらは型が混ざる場合と同様) 
				</p>
				<section>
					<h2>補足</h2>
					<p>
型にトレイトのメソッドをコピーする手法について。
					</p> <p>
これは『型 vs トレイト』で紹介した型優先のルールの応用である。
					</p> <p>
例: <a href="https://doc.rust-lang.org/std/ops/struct.Range.html"><code>Range</code></a> 型には <a href="https://doc.rust-lang.org/std/ops/trait.RangeBounds.html"><code>RangeBounds</code></a> トレイト由来の <a href="https://doc.rust-lang.org/std/ops/trait.RangeBounds.html#method.contains"><code>contains</code></a> メソッド、そして型それ自身の <a href="https://doc.rust-lang.org/std/ops/struct.Range.html#method.contains"><code>contains</code></a> メソッドの両方がある。後者は前者への中継のみを行うメソッドであり、一見するとこれは無意味だが、これによりどんなトレイト実装が適用されているかを気にせず <code>Range</code> の <code>contains</code> を通常記法で一意に呼び出せるようになる。
					</p>
				</section>
			</section>
		</section> <section>
			<h1>関連仕様</h1>
			<p>
Cargo における SemVer 互換性の解説より。
			</p> <p>
ここで紹介したメソッド追加の変更は「許容されうる破壊的変更」扱いらしい。
			</p>
			<doc-quote src="quote/cargo/reference/semver.xhtml"/>
		</section>
	</body>
</html>
