<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: E0716 - 一時的な値の参照中の破棄</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
<pre><samp class="console-rustc">
<mark class="error">error[E0716]</mark><mark class="title">: temporary value dropped while borrowed</mark>
</samp></pre>
		<p>
一時的な値が参照中に破棄された。
		</p>
		<section>
			<h1>パターン</h1>
			<doc-nav-sub/>
			<section>
				<hgroup>
					<h1 id="basic">パターン A</h1>
					<div class="subTitle">基本形</div>
				</hgroup>
				<p>
殆どの場合、式内の一時的な値は、文末 (セミコロンの位置) で破棄される。
				</p> <p>
そのため、それ以降にそれに由来する参照を使用するとエラーになる。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、一時的な値 <code>Foo::new()</code> の参照を <code>val_ref()</code> でたどり、結果を <code>ref_to_temp</code> に保存している。しかし、一時的な値はその文末ですぐに破棄されてしまう。そのため、以降にその参照にアクセスがあればエラーとなる。
					</p>
<pre><code class="language-rust">
fn main() {
    let ref_to_temp = <mark class="error">Foo::new()</mark>.val_ref();
    println!("Value is {}.", *ref_to_temp);
}

struct Foo {
    val: i32
}

impl Foo {
    fn new() -&gt; Self {
        Self { val: 0 }
    }
    
    fn val_ref(&amp;self) -&gt; &amp;i32 {
        &amp;self.val
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0716]</mark><mark class="title">: temporary value dropped while borrowed</mark>
<mark class="info"> --&gt;</mark> src\main.rs:2:21
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let ref_to_temp = Foo::new().val_ref();
<mark class="info">  |</mark>                       <mark class="error">^^^^^^^^^^</mark>          <mark class="info">- temporary value is freed at the end of this statement</mark>
<mark class="info">  |</mark>                       <mark class="error">|</mark>
<mark class="info">  |</mark>                       <mark class="error">creates a temporary value which is freed while still in use</mark>
<mark class="info">3 |</mark>     println!("Value is {}.", *ref_to_temp);
<mark class="info">  |</mark>                              <mark class="info">------------ borrow later used here</mark>
<mark class="info">  |</mark>
<mark class="info">help</mark>: consider using a `let` binding to create a longer lived value
<mark class="info">  |</mark>
<mark class="info">2</mark> <mark class="edit">~</mark>     <mark class="edit">let binding = Foo::new();</mark>
<mark class="info">3</mark> <mark class="edit">~</mark>     let ref_to_temp = <mark class="edit">binding</mark>.val_ref();
</samp></pre>
				</section> <section>
					<h2>解決策</h2>
					<p>
エラーメッセージの <q>help</q> にある通り、一時的な値をローカル変数に保存する。
					</p>
					<aside class="normal">
						<p>
Rust の独特な仕様。
						</p> <p>
Rust 以外の多くの言語では、ローカル変数に計算過程の中間値を保存するかは、主にリファクタリングの話題である。ところが、Rust ではこれによりエラーの有無が変わる。
						</p> <p>
これと関連してか、他の言語では「変数を宣言する」や「変数を値で初期化する」などと表現するところを、Rust では「変数に値を束縛する (let binding)」などと表現する。
						</p>
					</aside>
				</section>
			</section> <section>
				<hgroup>
					<h1>パターン B</h1>
					<div class="subTitle">参照式</div>
				</hgroup>
				<p>
参照式 (<code>&amp;<var>x</var></code>) は必要に応じて現在のスコープに演算対象 (<code><var>x</var></code>) を保存する。そのため、一時的な値に由来する参照でも、この場合は<a href="#basic">基本形</a>のパターンとは異なり、その参照がすぐに使えなくなる事はない。ただし、スコープを超えた利用ではやはりエラーになる。
				</p>
				<section>
					<h2>サンプル</h2>
					<p>
以下では、参照式により一時的な値に由来する <code>Foo::new().val</code> がスコープに保存される。そのため、それを参照する <code>ref_to_temp</code> の使用は妥当である。しかし、関数 <code>use_ref</code> の引数のライフタイムは <code>'static</code> であるため、その保存期間を超えてしまっている。
					</p>
<pre><code class="language-rust">
fn main() {
    let ref_to_temp = &amp;<mark class="error">Foo::new()</mark>.val;
    use_ref(ref_to_temp);
}

fn use_ref(arg: &amp;'static i32) {
    println!("Value is {}.", *arg);
}

struct Foo {
    val: i32
}

impl Foo {
    fn new() -&gt; Self {
        Self { val: 0 }
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="error">error[E0716]</mark><mark class="title">: temporary value dropped while borrowed</mark>
<mark class="info"> --&gt;</mark> src\main.rs:2:24
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let ref_to_temp = &amp;Foo::new().val;
<mark class="info">  |</mark>                        <mark class="error">^^^^^^^^^^ creates a temporary value which is freed while still in use</mark>
<mark class="info">3 |</mark>     use_ref(ref_to_temp);
<mark class="info">  |</mark>     <mark class="info">-------------------- argument requires that borrow lasts for `'static`</mark>
<mark class="info">4 |</mark> }
<mark class="info">  |</mark> <mark class="info">- temporary value is freed at the end of this statement</mark>
</samp></pre>
				</section>
			</section> <section>
				<hgroup>
					<h1 id="withDrop">パターン C</h1>
					<div class="subTitle"><code>Drop</code> トレイトの影響</div>
				</hgroup>
				<p>
詳しくは『<a href="e_drop_lifetime.xhtml">Drop トレイトのライフタイムへの影響</a> - <a href="e_drop_lifetime.xhtml#exLifetime">ライフタイムの延長</a>』を参照。
<br /> (注: <code>Drop</code> トレイトを直接的に扱っていなくても考慮が必要。)
				</p>
				<section>
					<h2>基本形との関係</h2>
					<p>
このパターンは変数をバインドだけして使用しないレアケースで発生する。<br/>
変数を使用すると、<a href="#basic">基本形</a>のパターンのメッセージに変わる。
					</p>
				</section> <section>
					<h2>サンプル</h2>
					<p>
<code>_var</code> を使用すると<a href="#basic">基本形</a>のパターンのメッセージに変わる<br/>
					</p>
<pre><code class="language-rust">
fn main() {
    let _var = temp().my_ref();
}

fn temp() -&gt; MyType {
    MyType(0)
}

struct MyType(i32);
impl MyType {
    pub fn my_ref(&amp;self) -&gt; MyRef&lt;'_&gt; {
        MyRef(&amp;self.0)
    }
}

struct MyRef&lt;'a&gt;(&amp;'a i32);
impl Drop for MyRef&lt;'_&gt; {
    fn drop(&amp;mut self) {
        println!("ID [{}] is drpoped.", self.0)
    }
}
</code></pre>
<pre><samp class="console-rustc">
<mark class="info">error[E0716]</mark><mark class="title">: temporary value dropped while borrowed</mark>
<mark class="info"> --&gt;</mark> src\main.rs:2:16
<mark class="info">  |</mark>
<mark class="info">2 |</mark>     let _var = temp().my_ref();
<mark class="info">  |</mark>                <mark class="error">^^^^^^</mark>         <mark class="info">- temporary value is freed at the end of this statement</mark>
<mark class="info">  |</mark>                <mark class="error">|</mark>
<mark class="info">  |</mark>                <mark class="error">creates a temporary value which is freed while still in use</mark>
<mark class="info">3 |</mark> }
<mark class="info">  |</mark> <mark class="info">- borrow might be used here, when `_var` is dropped and runs the `Drop` code for type `MyRef`</mark>
<mark class="info">  |</mark>
<mark class="info">help</mark>: consider using a `let` binding to create a longer lived value
<mark class="info">  |</mark>
<mark class="info">2</mark> <mark class="edit">~</mark>     <mark class="edit">let binding = temp();</mark>
<mark class="info">3</mark> <mark class="edit">~</mark>     let _var = <mark class="edit">binding</mark>.my_ref();
<mark class="info">  |</mark>
</samp></pre>
				</section>
			</section>
		</section>
	</body>
</html>
