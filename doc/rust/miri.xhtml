<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: MIRI の使用方法</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
		<p>
<a href="https://github.com/rust-lang/miri">MIRI</a> は UB (<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Undefineded Behavior</a>) の検出ツールである。 <br/>
<code>unsafe</code> を含む Rust コードの健全性の確認に使われる。
		</p>
		<aside class="normal">
			<p>名前の由来</p> 
			<p>
MIRI の名前はそれが Rust の中間表現である MIR (Rust's Mid-level Inter&#xAD;mediate Repre&#xAD;sen&#xAD;tation) の解釈プログラム (Interpreter) として動作する事に由来している。
			</p> 
		</aside>
		<section>
			<h1>現状と必要性</h1>
			<p>
<time>2025 年現在</time>、MIRI はまだ実験段階のため、ナイトリー版でのみ動作する。
			</p> <p>
とはいえ、<code>unsafe</code> なコードを扱う場合、筆者はこのツールはほぼ必須だと考えている。
			</p> <p>
なぜなら、健全性の問題は人間にとって盲点になるものが多い。また、不健全なコードはその時点では問題なく動作しても、将来的な Rust の更新の影響を受ける可能性がある。MIRI はそれらの予防にもなる。
			</p>
		</section> <section>
			<h1>実行方法</h1>
				<p>
それぞれ以下のコマンドから実行できる。
				</p>
			<section>
				<h2>インストール</h2>
<pre><code class="console">
<mark class="prompt">&gt;</mark> rustup +nightly component add miri
</code></pre>
			</section> <section>
				<h2>バイナリの実行</h2>
<pre><code class="console">
<mark class="prompt">&gt;</mark> cargo +nightly miri run
</code></pre>
			</section> <section>
				<h2>テストの実行</h2>
<pre><code class="console">
<mark class="prompt">&gt;</mark> cargo +nightly miri test
</code></pre>
			</section>
		</section> <section>
			<h1>注意点</h1>
			<section>
				<h2>偽陽性なし</h2>
				<p>
エラーがあればそれは何らかの不健全性がある事を示している。
				</p> <p>
ただし、<time>2025 年現在</time>の重要な点として、後述の<a href="#model">モデル</a>による差異がある。
				</p>
			</section> <section>
				<h2>偽陰性あり</h2>
				<p>
ツールの性質上、偽陰性は避けられない。
				</p> <p>
なぜなら、UB になるパターンがテストされていないだけの可能性は常にある。
				</p>
			</section> <section>
				<h2 id="model">モデル</h2>
				<p>
<time>2025 年現在</time>、Rust の <code>unsafe</code> まわりにはまだ曖昧さが残っている。
				</p> <p>
これに対して、MIRI は二つのモデル <dfn id="sb">Stacked Borrows</dfn> と <dfn id="tb">Tree Borrows</dfn> を用意している。どちらでもメモリ安全性は守られるが、後者は制限がより少ない。現在の既定は前者だが、将来的には後者が有力である。後者に切り替える場合、環境変数 <code>MIRIFLAGS</code> に <code>-Zmiri-tree-borrows</code> を指定するとよい。
				</p> <p>
ちなみに、将来的に Stacked Borrow より Tree Borrows が有力とする根拠は、前者が現状の多くのクレートの実情にそぐわないからである (参考: <a href="miri_sb_vs_arraydeque.xhtml"><code>arraydeque</code> での実例</a>)。
				</p>
			</section>
		</section> <section>
			<h1>事例集</h1>
			<ul>
				<li>
<a href="miri_removed_item.xhtml">MIRI エラー / 削除済のアイテムの利用</a>
				</li> <li>
<a href="miri_protected_item.xhtml">MIRI エラー / 保護されたアイテムの削除</a>
				</li>
			</ul>
		</section>
	</body>
</html>
