<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
	<head>
		<title>Rust メモ: Miri の使用方法</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="../../lib/doc.js"></script>
		<script src="lib/base.js"></script>
	</head>
	<body>
		<header>
			<h1><doc-title/></h1>
		</header>
		<p>
<a href="https://github.com/rust-lang/miri">Miri</a> は<a href="undefined_behavior.xhtml#ub">未定義動作</a> (UB: Undefined Behavior) の検出ツールである。 <br/>
<code>unsafe</code> を含むコードの検証やその<a href="undefined_behavior.xhtml#soundness">健全性</a>の確認に使われる。
		</p>
		<aside class="normal">
			<p>名前の由来</p> 
			<p>
Miri は Rust の中間表現 (MIR: Mid-level Inter&#xAD;mediate Repre&#xAD;sen&#xAD;tation) の解釈プログラム (Inter&#xAD;preter) として動作する。この事は名前の由来にもなっている。
			</p> 
		</aside>
		<section>
			<h1>現状と必要性</h1>
			<p>
<time>2025 年現在</time>、Miri はまだ実験段階のため、ナイトリー版でのみ動作する。
			</p> <p>
とはいえ、<code>unsafe</code> なコードを扱う場合、筆者はこのツールはほぼ必須だと考えている。
			</p> <p>
なぜなら、未定義動作にはエラーの発生有無が偶然に左右される物があり、見逃されやすい。また、Rust のバージョンアップなどで最適化方法が変更されると、その影響を受ける可能性もある。Miri はこれらの問題の対策となる。
			</p>
		</section> <section>
			<h1>実行方法</h1>
				<p>
それぞれ以下のコマンドから実行できる。
				</p>
			<section>
				<h2>インストール</h2>
<pre><code class="console">
<mark class="prompt">&gt;</mark> rustup +nightly component add miri
</code></pre>
			</section> <section>
				<h2>バイナリの実行</h2>
<pre><code class="console">
<mark class="prompt">&gt;</mark> cargo +nightly miri run
</code></pre>
			</section> <section>
				<h2>テストの実行</h2>
<pre><code class="console">
<mark class="prompt">&gt;</mark> cargo +nightly miri test
</code></pre>
			</section>
		</section> <section>
			<h1>注意点</h1>
			<section>
				<h2>偽陽性なし</h2>
				<p>
エラーがあればそれは何らかの未定義動作がある事を示している。
				</p> <p>
ただし、<time>2025 年現在</time>の重要な点として、後述の<a href="#model">モデル</a>による差異がある。
				</p>
			</section> <section>
				<h2>偽陰性あり</h2>
				<p>
ツールの性質上、偽陰性は避けられない。
				</p> <p>
なぜなら、UB になるパターンがテストされていないだけの可能性は常にある。
				</p>
			</section> <section>
				<h2 id="model">モデル</h2>
				<p>
<time>2025 年現在</time>、Rust のエイリアシングルールは <code>unsafe</code> まわりにまだ曖昧さがある。
				</p> <p>
これに対して、Miri は二つのモデル <dfn id="sb">Stacked Borrows</dfn> と <dfn id="tb">Tree Borrows</dfn> を用意している。どちらでもメモリ安全性は守られるが、後者は制限がより少ない。現在の既定は前者だが、将来的には後者が有力である。後者に切り替える場合、環境変数 <code>MIRIFLAGS</code> に <code>-Zmiri-tree-borrows</code> を指定するとよい。
				</p> <p>
ちなみに、将来的に Stacked Borrows より Tree Borrows が有力とする根拠は、前者が現状の多くのクレートの実情にそぐわないからである (参考: <a href="miri_sb_vs_arraydeque.xhtml"><code>arraydeque</code> での実例</a>)。
				</p>
			</section>
		</section> <section>
			<h1>事例集</h1>
			<ul>
				<li>
<a href="miri_dangling_pointer.xhtml">Miri エラー / ダングリングポインタ</a>
				</li> <li>
<a href="miri_memory_leak.xhtml">Miri エラー / メモリリーク</a>
				</li> <li>
<a href="miri_removed_item.xhtml">Miri エラー / 削除済のアイテムの利用</a>
				</li> <li>
<a href="miri_protected_item.xhtml">Miri エラー / 保護されたアイテムの削除</a>
				</li>
			</ul>
		</section>
	</body>
</html>
