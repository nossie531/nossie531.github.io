<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
	  xmlns:m="http://www.w3.org/1998/Math/MathML"
	  xml:lang="ja">
	<head>
		<title>Gram-Schmidt 法</title>
		<link rel="stylesheet" href="style/base.css"/>
		<script src="lib/base.js"></script>
		<script defer="defer" src="../../lib/katex/katex.min.js"></script>
		<script defer="defer" src="../../lib/katex/contrib/auto-render.min.js"></script>
	</head>
	<body>
		<header>
			<h1><script>Base.insertTitle();</script></h1>
		</header>
		<p>
このアルゴリズムでは、入力に線形独立なベクトルの組を与え、出力にそれらと同じ部分空間を張る正規直行系のベクトルの組を得る。
		</p> 
		<section>
			<h1>導入</h1>
			<section>
				<h1>基本戦略</h1>
				<p>
最初にまとめて直交化して、最後にまとめて正規化する。
				</p>
				<section>
					<h2>直交化</h2>
					<p>
ベクトルから直行化済のベクトルの成分を全て除去すると、新たに直行化したベクトルが一つ増える。この作業を繰り返して全てのベクトルを直交化させる。
					</p> <p>
以下では、ベクトル \(\boldsymbol{x}_3\) を直行化が完了済のベクトル \(\boldsymbol{y}_1\) と \(\boldsymbol{y}_2\) に直交化させ、\(\boldsymbol{y}_3\) を求めている。ここで、\(\operatorname{proj}(\boldsymbol{x}_3, \boldsymbol{y}_1)\) と \(\operatorname{proj}(\boldsymbol{x}_3, \boldsymbol{y}_2)\) は \(\boldsymbol{x}_3\) の \(\boldsymbol{y}_1\) と \(\boldsymbol{y}_2\) 方向の成分を表す。
					</p>
					<figure class="normal">
						<object data="img/gramSchmidt.svg" style="height: 30rem;"></object>
						<figcaption>直交化のイメージ</figcaption>
					</figure>
				</section> <section>
					<h2>正規化</h2>
					<p>
直交化された各ベクトルをその大きさで割り、単位ベクトルに変換する。
					</p> <p>
(直交化だけが目的の場合、この作業は省略可能。)
					</p>
				</section>
			</section> <section>
				<h1>記号の定義</h1>
				<ul>
					<li>
入力ベクトルの組: \(\{\boldsymbol{x}_1, \boldsymbol{x}_2, \cdots, \boldsymbol{x}_n\}\)
					</li> <li>
直行ベクトルの組: \(\{\boldsymbol{y}_1, \boldsymbol{y}_2, \cdots, \boldsymbol{y}_n\}\)
					</li>
				</ul>
			</section> <section>
				<h1>操作の定義</h1>
				<p>
平行成分は以下のように求められる。
				</p>
				<div class="math">
\[\operatorname{proj}(\boldsymbol{a}, \boldsymbol{b}) =
\frac
	{\langle \boldsymbol{a}, \boldsymbol{b} \rangle}
	{\langle \boldsymbol{b}, \boldsymbol{b} \rangle}
\boldsymbol{b}\]
				</div>
			</section>
		</section> <section>
			<h1>各種アルゴリズム</h1>
			<section>
				<h1>古典的 Gram-Schmidt 法</h1>
				<section>
					<h2>特徴</h2>
					<p>
数学的には正しいが、計算機で解くと誤差が大きくなる。
					</p>
				</section> <section>
					<h2>手順</h2>
					<p>
直行化における平行成分の計算を愚直に行う。
					</p> <p>
つまり、\(\boldsymbol{y}_k\) は以下のように計算される。
					</p>
					<div class="math">
\[\boldsymbol{y}_k = \boldsymbol{x}_k - \sum_{i=1}^{k-1}{\operatorname{proj}(\boldsymbol{x}_k,\boldsymbol{y}_i)}\]
					</div>
				</section>
			</section> <section>
				<h1>修正 Gram-Schmidt 法</h1>
				<section>
					<h2>特徴</h2>
					<p>
数学的には古典版と同じだが、計算機で解いた場合の誤差がそれより小さい。
					</p>
				</section> <section>
					<h2>手順</h2>
					<p>
直行化における平行成分の計算を、対象ベクトルから他の平行成分を除去した後に行う。
					</p> <p>
つまり、\(\boldsymbol{y}_k\) は以下のように計算される。
					</p>
					<div class="math">
\[\boldsymbol{y}_k = \boldsymbol{y}_k^{(k)}\]
					</div>
					<div class="math">
\[\boldsymbol{y}_k^{(i)} = \boldsymbol{y}_k^{(i-1)} - \operatorname{proj}(\boldsymbol{y}_k^{(i-1)},\boldsymbol{y}_i)\]
					</div>
					<div class="math">
\[\boldsymbol{y}_k^{(0)} = \boldsymbol{x}_k\]
					</div>
					<p>
ここで \(\{\boldsymbol{y}_k^{(1)}, \cdots, \boldsymbol{y}_k^{(k-1)}\}\) は \(\boldsymbol{y}_k\) の計算途中のワーク変数である。
					</p>
				</section> <section>
					<h2>備考 (誤差の改良点)</h2>
					<p>
古典版と修正版、それぞれの \(i\) 回目のループの以下の箇所に着目する。
					</p> <p>
古典版: \(\operatorname{proj}(\boldsymbol{x}_k, \boldsymbol{y}_i)\)
					</p> <p>
修正版: \(\operatorname{proj}(\boldsymbol{y}_k^{(i-1)},\boldsymbol{y}_i)\)
					</p> <p>
ここで、古典版の第一引数は常に \(\boldsymbol{x}_k\) である。一方、修正版は \(\boldsymbol{y}_k^{(i-1)}\) でこれは \(i=1\) では古典版と同じだが、\(i\) が一つ増えるたびに各成分が除去されていくため、その絶対値も減少していく。これにより、平行成分の計算に誤差があっても、それも必ず減少していく。この積み重ねが原因で、修正版のほうが誤差が小さくなる。
					</p>
				</section>
			</section>
		</section>
	</body>
</html>
